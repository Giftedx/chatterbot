/**
 * Document Processing Service
 * Comprehensive document analysis including text extraction, structure analysis, and content intelligence
 */

import {
  MediaFile,
  DocumentAnalysisResult,
  FileProcessingOptions,
  DocumentMetadata,
  ProcessingStatus,
  DocumentSection,
  ContentType
} from './types.js';
import { prisma } from '../db/prisma.js';
import { logger } from '../utils/logger.js';

/**
 * Service for analyzing documents and extracting structured information
 */
export class DocumentProcessingService {
  private readonly supportedFormats: Set<string>;
  private readonly maxFileSize: number; // 25MB
  
  constructor() {
    this.supportedFormats = new Set([
      'application/pdf',
      'application/msword',
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
      'application/vnd.ms-excel',
      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      'application/vnd.ms-powerpoint',
      'application/vnd.openxmlformats-officedocument.presentationml.presentation',
      'text/plain',
      'text/markdown',
      'text/csv',
      'application/json',
      'application/rtf'
    ]);
    this.maxFileSize = 25 * 1024 * 1024; // 25MB
  }

  /**
   * Process document and extract comprehensive analysis
   */
  public async processDocument(
    mediaFile: MediaFile,
    options: FileProcessingOptions = {}
  ): Promise<DocumentAnalysisResult | null> {
    try {
      const startTime = Date.now();

      // Validate document file
      if (!this.isValidDocumentFile(mediaFile)) {
        logger.warn('Invalid document file for processing', {
          operation: 'document-processing',
          metadata: {
            fileId: mediaFile.id,
            mimeType: mediaFile.mimeType,
            fileSize: mediaFile.fileSize
          }
        });
        return null;
      }

      // Update processing status
      await this.updateProcessingStatus(mediaFile.id, 'processing');

      const analysisResult: DocumentAnalysisResult = {};

      // Extract document metadata
      const documentMetadata = await this.extractDocumentMetadata(mediaFile);
      
      // Extract text content
      if (options.enableTextExtraction !== false) {
        analysisResult.textContent = await this.extractTextContent(mediaFile);
      }

      // Analyze document structure
      if (options.enableStructureAnalysis !== false) {
        analysisResult.structure = await this.analyzeDocumentStructure(mediaFile, analysisResult.textContent);
      }

      // Classify document type and content
      analysisResult.classification = await this.classifyDocument(mediaFile, analysisResult.textContent);

      // Extract key information
      if (options.enableKeywordExtraction !== false && analysisResult.textContent) {
        analysisResult.keyInformation = await this.extractKeyInformation(analysisResult.textContent);
      }

      // Assess content quality and readability
      if (analysisResult.textContent) {
        analysisResult.qualityMetrics = await this.assessContentQuality(analysisResult.textContent);
      }

      // Generate summary if content exists
      if (options.enableSummarization !== false && analysisResult.textContent) {
        analysisResult.summary = await this.generateDocumentSummary(analysisResult.textContent);
      }

      // Generate description and extract tags
      const description = this.generateDocumentDescription(analysisResult, documentMetadata);
      const tags = this.extractTagsFromAnalysis(analysisResult);
      const categories = this.categorizeDocument(analysisResult);

      // Update media file with analysis results
      await this.updateMediaFileWithAnalysis(mediaFile.id, {
        documentAnalysis: analysisResult,
        documentMetadata,
        extractedText: analysisResult.textContent?.fullText,
        description,
        tags,
        categories,
        processingStatus: 'completed',
        processedAt: new Date()
      });

      const processingTime = Date.now() - startTime;

      logger.info('Document processing completed', {
        operation: 'document-processing',
        userId: mediaFile.userId,
        metadata: {
          fileId: mediaFile.id,
          documentType: analysisResult.classification?.documentType,
          textLength: analysisResult.textContent?.fullText?.length || 0,
          pageCount: documentMetadata?.pageCount || 0,
          wordCount: analysisResult.textContent?.wordCount || 0,
          processingTime
        }
      });

      return analysisResult;

    } catch (error) {
      logger.error('Failed to process document', {
        operation: 'document-processing',
        metadata: {
          fileId: mediaFile.id,
          error: String(error)
        }
      });

      await this.updateProcessingStatus(mediaFile.id, 'failed', String(error));
      return null;
    }
  }

  /**
   * Extract document metadata
   */
  private async extractDocumentMetadata(mediaFile: MediaFile): Promise<DocumentMetadata | null> {
    try {
      // In a real implementation, this would use libraries like pdf-parse, 
      // mammoth.js, xlsx, etc. to extract metadata
      
      // Mock metadata extraction based on file type
      const metadata: DocumentMetadata = {
        pageCount: this.estimatePageCount(mediaFile),
        wordCount: 0, // Will be set after text extraction
        language: 'en',
        author: undefined,
        title: this.extractTitleFromFilename(mediaFile.originalName),
        createdDate: undefined,
        modifiedDate: undefined,
        format: this.getDocumentFormat(mediaFile.mimeType)
      };

      logger.debug('Document metadata extracted', {
        operation: 'document-metadata',
        metadata: {
          fileId: mediaFile.id,
          pageCount: metadata.pageCount,
          format: metadata.format
        }
      });

      return metadata;

    } catch (error) {
      logger.error('Failed to extract document metadata', {
        operation: 'document-metadata',
        metadata: {
          fileId: mediaFile.id,
          error: String(error)
        }
      });
      return null;
    }
  }

  /**
   * Extract text content from document
   */
  private async extractTextContent(mediaFile: MediaFile) {
    try {
      // In a real implementation, this would use appropriate libraries:
      // - PDF: pdf-parse, pdf2pic
      // - Word: mammoth.js
      // - Excel/Sheets: xlsx
      // - PowerPoint: officegen or similar
      // - Plain text: fs.readFile
      
      // Mock text extraction
      const mockText = this.generateMockTextContent(mediaFile);
      
      const sections = this.splitIntoSections(mockText);
      const wordCount = mockText.split(/\s+/).length;
      const characterCount = mockText.length;

      logger.debug('Text content extracted', {
        operation: 'text-extraction',
        metadata: {
          fileId: mediaFile.id,
          wordCount,
          characterCount,
          sectionCount: sections.length
        }
      });

      return {
        fullText: mockText,
        sections,
        wordCount,
        characterCount,
        language: 'en'
      };

    } catch (error) {
      logger.error('Text extraction failed', {
        operation: 'text-extraction',
        metadata: {
          fileId: mediaFile.id,
          error: String(error)
        }
      });
      return undefined;
    }
  }

  /**
   * Analyze document structure
   */
  private async analyzeDocumentStructure(mediaFile: MediaFile, textContent?: any) {
    try {
      if (!textContent) {
        return undefined;
      }

      // Mock structure analysis
      const structure = {
        hasTitle: textContent.sections.length > 0,
        hasHeadings: textContent.sections.length > 1,
        hasTables: textContent.fullText.includes('table') || textContent.fullText.includes('|'),
        hasLists: textContent.fullText.includes('â€¢') || textContent.fullText.includes('1.'),
        sectionCount: textContent.sections.length,
        headingLevels: this.detectHeadingLevels(textContent.fullText),
        documentFlow: this.analyzeDocumentFlow(textContent.sections)
      };

      logger.debug('Document structure analyzed', {
        operation: 'structure-analysis',
        metadata: {
          fileId: mediaFile.id,
          sectionCount: structure.sectionCount,
          hasHeadings: structure.hasHeadings,
          hasTables: structure.hasTables
        }
      });

      return structure;

    } catch (error) {
      logger.error('Document structure analysis failed', {
        operation: 'structure-analysis',
        metadata: {
          fileId: mediaFile.id,
          error: String(error)
        }
      });
      return undefined;
    }
  }

  /**
   * Classify document type and content
   */
  private async classifyDocument(mediaFile: MediaFile, textContent?: any) {
    try {
      // Mock document classification based on content and filename
      const documentType = this.determineDocumentType(mediaFile, textContent);
      const contentType = this.determineContentType(textContent);
      
      const classification = {
        documentType,
        contentType,
        confidence: 0.85,
        categories: this.generateContentCategories(documentType, contentType, textContent)
      };

      logger.debug('Document classification completed', {
        operation: 'document-classification',
        metadata: {
          fileId: mediaFile.id,
          documentType,
          contentType,
          confidence: classification.confidence
        }
      });

      return classification;

    } catch (error) {
      logger.error('Document classification failed', {
        operation: 'document-classification',
        metadata: {
          fileId: mediaFile.id,
          error: String(error)
        }
      });
      
      return {
        documentType: 'unknown',
        contentType: 'general',
        confidence: 0.5,
        categories: []
      };
    }
  }

  /**
   * Extract key information from document
   */
  private async extractKeyInformation(textContent: any) {
    try {
      // Mock key information extraction
      const text = textContent.fullText;
      
      const keyInformation = {
        entities: this.extractEntities(text),
        keywords: this.extractKeywords(text),
        topics: this.extractTopics(text),
        importantSentences: this.extractImportantSentences(text),
        actionItems: this.extractActionItems(text),
        dates: this.extractDates(text),
        numbers: this.extractNumbers(text)
      };

      logger.debug('Key information extracted', {
        operation: 'key-extraction',
        metadata: {
          entityCount: keyInformation.entities.length,
          keywordCount: keyInformation.keywords.length,
          topicCount: keyInformation.topics.length
        }
      });

      return keyInformation;

    } catch (error) {
      logger.error('Key information extraction failed', {
        operation: 'key-extraction',
        metadata: {
          error: String(error)
        }
      });
      return undefined;
    }
  }

  /**
   * Assess content quality and readability
   */
  private async assessContentQuality(textContent: any) {
    try {
      const text = textContent.fullText;
      
      // Mock quality assessment
      const quality = {
        readabilityScore: this.calculateReadabilityScore(text),
        grammarQuality: this.assessGrammarQuality(text),
        structureQuality: this.assessStructureQuality(text),
        completeness: this.assessCompleteness(text),
        coherence: this.assessCoherence(text)
      };

      logger.debug('Content quality assessed', {
        operation: 'quality-assessment',
        metadata: {
          readabilityScore: quality.readabilityScore,
          grammarQuality: quality.grammarQuality
        }
      });

      return quality;

    } catch (error) {
      logger.error('Content quality assessment failed', {
        operation: 'quality-assessment',
        metadata: {
          error: String(error)
        }
      });
      
      return {
        readabilityScore: 0.5,
        grammarQuality: 0.5,
        structureQuality: 0.5,
        completeness: 0.5,
        coherence: 0.5
      };
    }
  }

  /**
   * Generate document summary
   */
  private async generateDocumentSummary(textContent: any) {
    try {
      const text = textContent.fullText;
      
      // Mock summary generation
      const sentences = text.split(/[.!?]+/).filter((s: string) => s.trim().length > 10);
      const importantSentences = sentences.slice(0, 3); // Take first 3 sentences as summary
      
      const summary = {
        brief: importantSentences[0] || 'Document processed successfully.',
        detailed: importantSentences.join('. ') + '.',
        keyPoints: this.extractKeyPoints(text),
        wordCount: importantSentences.join(' ').split(' ').length
      };

      logger.debug('Document summary generated', {
        operation: 'summary-generation',
        metadata: {
          summaryWordCount: summary.wordCount,
          keyPointCount: summary.keyPoints.length
        }
      });

      return summary;

    } catch (error) {
      logger.error('Document summary generation failed', {
        operation: 'summary-generation',
        metadata: {
          error: String(error)
        }
      });
      return undefined;
    }
  }

  // Helper methods for document processing

  private estimatePageCount(mediaFile: MediaFile): number {
    // Rough estimation based on file size and type
    const sizeKB = mediaFile.fileSize / 1024;
    
    if (mediaFile.mimeType.includes('pdf')) {
      return Math.max(1, Math.floor(sizeKB / 100)); // ~100KB per page for PDF
    } else if (mediaFile.mimeType.includes('word')) {
      return Math.max(1, Math.floor(sizeKB / 50)); // ~50KB per page for Word
    } else {
      return 1;
    }
  }

  private extractTitleFromFilename(filename: string): string {
    return filename
      .replace(/\.[^/.]+$/, '') // Remove extension
      .replace(/[-_]/g, ' ') // Replace dashes and underscores with spaces
      .replace(/\b\w/g, l => l.toUpperCase()); // Title case
  }

  private getDocumentFormat(mimeType: string): string {
    const formatMap: Record<string, string> = {
      'application/pdf': 'PDF',
      'application/msword': 'Word',
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document': 'Word',
      'application/vnd.ms-excel': 'Excel',
      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': 'Excel',
      'application/vnd.ms-powerpoint': 'PowerPoint',
      'application/vnd.openxmlformats-officedocument.presentationml.presentation': 'PowerPoint',
      'text/plain': 'Text',
      'text/markdown': 'Markdown',
      'text/csv': 'CSV',
      'application/json': 'JSON',
      'application/rtf': 'RTF'
    };
    
    return formatMap[mimeType] || 'Unknown';
  }

  private generateMockTextContent(mediaFile: MediaFile): string {
    // Generate appropriate mock content based on file type
    const format = this.getDocumentFormat(mediaFile.mimeType);
    
    switch (format) {
      case 'PDF':
        return 'This is a sample PDF document with multiple paragraphs. It contains structured information organized in sections. The document discusses important topics and provides detailed analysis of various subjects.';
      case 'Word':
        return 'Sample Word document content with formatted text. This document includes headings, bullet points, and detailed explanations. It represents a typical business or academic document structure.';
      case 'Excel':
        return 'Spreadsheet data summary: Contains numerical data, calculations, and tabular information. Includes multiple worksheets with financial or analytical data.';
      case 'PowerPoint':
        return 'Presentation slides content: Introduction slide, key points, supporting details, and conclusion. Visual elements and structured information for presentation purposes.';
      default:
        return 'Document content extracted successfully. Contains textual information that has been processed and analyzed for key insights and structure.';
    }
  }

  private splitIntoSections(text: string): DocumentSection[] {
    // Simple section splitting based on paragraph breaks
    const paragraphs = text.split(/\n\n+/).filter(p => p.trim().length > 0);
    
    return paragraphs.map((content, index) => ({
      title: index === 0 ? 'Introduction' : `Section ${index}`,
      content: content.trim(),
      level: 1,
      wordCount: content.split(/\s+/).length
    }));
  }

  private detectHeadingLevels(text: string): number[] {
    // Mock heading level detection
    const lines = text.split('\n');
    const headingPattern = /^#+\s/; // Markdown-style headings
    
    const levels = lines
      .filter(line => headingPattern.test(line))
      .map(line => (line.match(/^#+/) || [''])[0].length);
    
    return Array.from(new Set(levels)).sort();
  }

  private analyzeDocumentFlow(sections: DocumentSection[]): string {
    if (sections.length <= 1) return 'simple';
    if (sections.length <= 3) return 'basic';
    if (sections.length <= 6) return 'structured';
    return 'complex';
  }

  private determineDocumentType(mediaFile: MediaFile, textContent?: any): string {
    const filename = mediaFile.originalName.toLowerCase();
    const format = this.getDocumentFormat(mediaFile.mimeType);
    
    // Classify based on filename patterns
    if (filename.includes('resume') || filename.includes('cv')) return 'resume';
    if (filename.includes('report')) return 'report';
    if (filename.includes('proposal')) return 'proposal';
    if (filename.includes('contract')) return 'contract';
    if (filename.includes('manual')) return 'manual';
    if (filename.includes('invoice')) return 'invoice';
    
    // Classify based on format
    switch (format) {
      case 'Excel': return 'spreadsheet';
      case 'PowerPoint': return 'presentation';
      case 'PDF': return 'document';
      default: return 'text';
    }
  }

  private determineContentType(textContent?: any): ContentType {
    if (!textContent) return 'general';
    
    const text = textContent.fullText.toLowerCase();
    
    if (text.includes('financial') || text.includes('budget') || text.includes('revenue')) return 'financial';
    if (text.includes('legal') || text.includes('contract') || text.includes('agreement')) return 'legal';
    if (text.includes('technical') || text.includes('specification') || text.includes('documentation')) return 'technical';
    if (text.includes('academic') || text.includes('research') || text.includes('study')) return 'academic';
    if (text.includes('business') || text.includes('strategy') || text.includes('management')) return 'business';
    
    return 'general';
  }

  private generateContentCategories(documentType: string, contentType: ContentType, textContent?: any): string[] {
    const categories = new Set([documentType, contentType]);
    
    if (textContent) {
      const text = textContent.fullText.toLowerCase();
      
      if (text.includes('analysis')) categories.add('analytical');
      if (text.includes('plan') || text.includes('planning')) categories.add('planning');
      if (text.includes('instruction') || text.includes('guide')) categories.add('instructional');
      if (text.includes('summary') || text.includes('overview')) categories.add('summary');
    }
    
    return Array.from(categories);
  }

  private extractEntities(text: string): Array<{ text: string; type: string; confidence: number }> {
    // Mock entity extraction
    const entities = [];
    
    // Simple regex patterns for common entities
    const emailPattern = /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g;
    const phonePattern = /\b\d{3}-\d{3}-\d{4}\b|\b\(\d{3}\)\s*\d{3}-\d{4}\b/g;
    const urlPattern = /https?:\/\/[^\s]+/g;
    
    text.match(emailPattern)?.forEach(email => {
      entities.push({ text: email, type: 'email', confidence: 0.9 });
    });
    
    text.match(phonePattern)?.forEach(phone => {
      entities.push({ text: phone, type: 'phone', confidence: 0.85 });
    });
    
    text.match(urlPattern)?.forEach(url => {
      entities.push({ text: url, type: 'url', confidence: 0.95 });
    });
    
    return entities.slice(0, 10); // Limit to 10 entities
  }

  private extractKeywords(text: string): string[] {
    // Simple keyword extraction based on word frequency
    const words = text.toLowerCase()
      .replace(/[^\w\s]/g, '')
      .split(/\s+/)
      .filter(word => word.length > 3);
    
    const frequency: Record<string, number> = {};
    words.forEach(word => {
      frequency[word] = (frequency[word] || 0) + 1;
    });
    
    return Object.entries(frequency)
      .sort(([, a], [, b]) => b - a)
      .slice(0, 10)
      .map(([word]) => word);
  }

  private extractTopics(text: string): string[] {
    // Mock topic extraction
    const topicKeywords = {
      'business': ['business', 'company', 'management', 'strategy', 'revenue'],
      'technology': ['technology', 'software', 'system', 'technical', 'development'],
      'finance': ['financial', 'budget', 'cost', 'revenue', 'investment'],
      'legal': ['legal', 'contract', 'agreement', 'compliance', 'regulation'],
      'education': ['education', 'learning', 'training', 'course', 'academic']
    };
    
    const textLower = text.toLowerCase();
    const topics = [];
    
    for (const [topic, keywords] of Object.entries(topicKeywords)) {
      if (keywords.some(keyword => textLower.includes(keyword))) {
        topics.push(topic);
      }
    }
    
    return topics;
  }

  private extractImportantSentences(text: string): string[] {
    const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 20);
    
    // Score sentences based on position and keywords
    const scoredSentences = sentences.map((sentence, index) => {
      let score = 0;
      
      // Position-based scoring (beginning and end are important)
      if (index < 2) score += 3;
      if (index >= sentences.length - 2) score += 2;
      
      // Keyword-based scoring
      const importantWords = ['important', 'key', 'critical', 'essential', 'significant', 'main', 'primary'];
      importantWords.forEach(word => {
        if (sentence.toLowerCase().includes(word)) score += 2;
      });
      
      return { sentence: sentence.trim(), score };
    });
    
    return scoredSentences
      .sort((a, b) => b.score - a.score)
      .slice(0, 3)
      .map(item => item.sentence);
  }

  private extractActionItems(text: string): string[] {
    // Look for action-oriented sentences
    const actionWords = ['must', 'should', 'need to', 'required', 'action', 'todo', 'task'];
    const sentences = text.split(/[.!?]+/);
    
    return sentences
      .filter(sentence => 
        actionWords.some(word => sentence.toLowerCase().includes(word))
      )
      .map(sentence => sentence.trim())
      .slice(0, 5);
  }

  private extractDates(text: string): string[] {
    const datePatterns = [
      /\b\d{1,2}\/\d{1,2}\/\d{4}\b/g, // MM/DD/YYYY
      /\b\d{4}-\d{2}-\d{2}\b/g, // YYYY-MM-DD
      /\b(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[a-z]*\s+\d{1,2},?\s+\d{4}\b/gi // Month DD, YYYY
    ];
    
    const dates = [];
    datePatterns.forEach(pattern => {
      const matches = text.match(pattern);
      if (matches) dates.push(...matches);
    });
    
    return Array.from(new Set(dates)).slice(0, 10);
  }

  private extractNumbers(text: string): Array<{ value: string; context: string }> {
    const numberPattern = /\b\d+(?:\.\d+)?(?:%|\$|â‚¬|Â£)?\b/g;
    const matches = text.match(numberPattern) || [];
    
    return matches.slice(0, 10).map(value => ({
      value,
      context: this.getNumberContext(text, value)
    }));
  }

  private getNumberContext(text: string, number: string): string {
    const index = text.indexOf(number);
    const start = Math.max(0, index - 20);
    const end = Math.min(text.length, index + number.length + 20);
    return text.substring(start, end).trim();
  }

  private calculateReadabilityScore(text: string): number {
    // Simple Flesch Reading Ease approximation
    const sentences = text.split(/[.!?]+/).length;
    const words = text.split(/\s+/).length;
    const syllables = this.countSyllables(text);
    
    const avgWordsPerSentence = words / sentences;
    const avgSyllablesPerWord = syllables / words;
    
    const score = 206.835 - (1.015 * avgWordsPerSentence) - (84.6 * avgSyllablesPerWord);
    return Math.max(0, Math.min(100, score)) / 100; // Normalize to 0-1
  }

  private countSyllables(text: string): number {
    // Simple syllable counting approximation
    const vowels = 'aeiouAEIOU';
    let count = 0;
    let prevWasVowel = false;
    
    for (const char of text) {
      const isVowel = vowels.includes(char);
      if (isVowel && !prevWasVowel) {
        count++;
      }
      prevWasVowel = isVowel;
    }
    
    return Math.max(1, count); // At least 1 syllable per word
  }

  private assessGrammarQuality(text: string): number {
    // Simple grammar quality assessment
    let score = 1.0;
    
    // Check for basic grammar rules
    const sentences = text.split(/[.!?]+/);
    sentences.forEach(sentence => {
      const words = sentence.trim().split(/\s+/);
      if (words.length > 0) {
        // Check if first word is capitalized
        if (words[0] && words[0][0] !== words[0][0].toUpperCase()) {
          score -= 0.1;
        }
      }
    });
    
    // Check for excessive repetition
    const words = text.toLowerCase().split(/\s+/);
    const uniqueWords = new Set(words);
    const repetitionRatio = uniqueWords.size / words.length;
    if (repetitionRatio < 0.5) score -= 0.2;
    
    return Math.max(0, Math.min(1, score));
  }

  private assessStructureQuality(text: string): number {
    const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
    const paragraphs = text.split(/\n\n+/).filter(p => p.trim().length > 0);
    
    let score = 0.5; // Base score
    
    // Reward good paragraph structure
    if (paragraphs.length > 1) score += 0.2;
    if (paragraphs.length > 3) score += 0.1;
    
    // Reward balanced sentence lengths
    const avgSentenceLength = text.length / sentences.length;
    if (avgSentenceLength > 50 && avgSentenceLength < 200) score += 0.2;
    
    return Math.max(0, Math.min(1, score));
  }

  private assessCompleteness(text: string): number {
    // Assess if document seems complete based on common patterns
    let score = 0.5; // Base score
    
    // Check for conclusion indicators
    if (text.toLowerCase().includes('conclusion') || 
        text.toLowerCase().includes('summary') ||
        text.toLowerCase().includes('finally')) {
      score += 0.3;
    }
    
    // Check for structural completeness
    const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
    if (sentences.length > 5) score += 0.2;
    
    return Math.max(0, Math.min(1, score));
  }

  private assessCoherence(text: string): number {
    // Simple coherence assessment based on transition words and repetition
    const transitionWords = [
      'however', 'therefore', 'furthermore', 'moreover', 'additionally',
      'consequently', 'meanwhile', 'nevertheless', 'although', 'because'
    ];
    
    const textLower = text.toLowerCase();
    const transitionCount = transitionWords.filter(word => textLower.includes(word)).length;
    
    const sentences = text.split(/[.!?]+/).length;
    const transitionRatio = transitionCount / sentences;
    
    return Math.max(0, Math.min(1, 0.3 + (transitionRatio * 2))); // Scale to 0-1
  }

  private extractKeyPoints(text: string): string[] {
    // Extract sentences that appear to be key points
    const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 10);
    
    const keyPointIndicators = [
      'key', 'important', 'main', 'primary', 'essential', 'critical',
      'significant', 'major', 'fundamental', 'crucial'
    ];
    
    const keyPoints = sentences.filter(sentence => {
      const lowerSentence = sentence.toLowerCase();
      return keyPointIndicators.some(indicator => lowerSentence.includes(indicator));
    });
    
    return keyPoints.slice(0, 5).map(point => point.trim());
  }

  /**
   * Generate natural language description of document
   */
  private generateDocumentDescription(analysis: DocumentAnalysisResult, metadata: DocumentMetadata | null): string {
    const parts: string[] = [];

    // Add document type and format
    if (analysis.classification) {
      parts.push(`${analysis.classification.documentType} document`);
      if (metadata?.format) {
        parts.push(`in ${metadata.format} format`);
      }
    }

    // Add content information
    if (analysis.textContent) {
      parts.push(`containing ${analysis.textContent.wordCount} words`);
      if (metadata?.pageCount && metadata.pageCount > 1) {
        parts.push(`across ${metadata.pageCount} pages`);
      }
    }

    // Add structure information
    if (analysis.structure) {
      if (analysis.structure.hasHeadings) {
        parts.push(`with structured headings`);
      }
      if (analysis.structure.hasTables) {
        parts.push(`including tables`);
      }
    }

    // Add content type
    if (analysis.classification?.contentType && analysis.classification.contentType !== 'general') {
      parts.push(`focusing on ${analysis.classification.contentType} content`);
    }

    // Add quality assessment
    if (analysis.qualityMetrics) {
      const readability = analysis.qualityMetrics.readabilityScore > 0.7 ? 'high' : 
                         analysis.qualityMetrics.readabilityScore > 0.4 ? 'medium' : 'low';
      parts.push(`with ${readability} readability`);
    }

    return parts.join(', ') || 'Document processed successfully';
  }

  /**
   * Extract tags from document analysis
   */
  private extractTagsFromAnalysis(analysis: DocumentAnalysisResult): string[] {
    const tags = new Set<string>();

    // Add classification tags
    if (analysis.classification) {
      tags.add(analysis.classification.documentType);
      tags.add(analysis.classification.contentType);
      analysis.classification.categories.forEach((cat: string) => tags.add(cat));
    }

    // Add structure tags
    if (analysis.structure) {
      if (analysis.structure.hasHeadings) tags.add('structured');
      if (analysis.structure.hasTables) tags.add('tabular');
      if (analysis.structure.hasLists) tags.add('listed');
    }

    // Add content-based tags
    if (analysis.keyInformation) {
      analysis.keyInformation.topics.forEach((topic: string) => tags.add(topic));
      
      if (analysis.keyInformation.entities.length > 0) tags.add('entities');
      if (analysis.keyInformation.actionItems.length > 0) tags.add('actionable');
      if (analysis.keyInformation.dates.length > 0) tags.add('time-sensitive');
    }

    // Add quality tags
    if (analysis.qualityMetrics) {
      if (analysis.qualityMetrics.readabilityScore > 0.8) tags.add('readable');
      if (analysis.qualityMetrics.structureQuality > 0.7) tags.add('well-structured');
    }

    return Array.from(tags).slice(0, 15);
  }

  /**
   * Categorize document based on analysis
   */
  private categorizeDocument(analysis: DocumentAnalysisResult): string[] {
    const categories = new Set<string>();

    // Primary categorization
    categories.add('document');

    // Type-based categorization
    if (analysis.classification) {
      switch (analysis.classification.documentType) {
        case 'report':
          categories.add('business');
          categories.add('analytical');
          break;
        case 'proposal':
          categories.add('business');
          categories.add('planning');
          break;
        case 'contract':
          categories.add('legal');
          categories.add('formal');
          break;
        case 'resume':
          categories.add('personal');
          categories.add('professional');
          break;
        case 'manual':
          categories.add('instructional');
          categories.add('technical');
          break;
        case 'presentation':
          categories.add('visual');
          categories.add('educational');
          break;
        case 'spreadsheet':
          categories.add('data');
          categories.add('analytical');
          break;
      }

      // Content-based categorization
      switch (analysis.classification.contentType) {
        case 'financial':
          categories.add('finance');
          categories.add('business');
          break;
        case 'legal':
          categories.add('legal');
          categories.add('compliance');
          break;
        case 'technical':
          categories.add('technical');
          categories.add('documentation');
          break;
        case 'academic':
          categories.add('academic');
          categories.add('research');
          break;
      }
    }

    // Quality-based categorization
    if (analysis.qualityMetrics && analysis.qualityMetrics.readabilityScore > 0.8) {
      categories.add('high_quality');
    }

    return Array.from(categories);
  }

  /**
   * Validate if file is a supported document format
   */
  private isValidDocumentFile(mediaFile: MediaFile): boolean {
    return (
      mediaFile.fileType === 'document' &&
      this.supportedFormats.has(mediaFile.mimeType) &&
      mediaFile.fileSize <= this.maxFileSize
    );
  }

  /**
   * Update media file processing status
   */
  private async updateProcessingStatus(
    fileId: number,
    status: ProcessingStatus,
    error?: string
  ): Promise<void> {
    try {
      await prisma.mediaFile.update({
        where: { id: fileId },
        data: {
          processingStatus: status,
          processingError: error,
          processedAt: status === 'completed' || status === 'failed' ? new Date() : undefined
        }
      });
    } catch (updateError) {
      logger.error('Failed to update processing status', {
        operation: 'status-update',
        metadata: {
          fileId,
          status,
          error: String(updateError)
        }
      });
    }
  }

  /**
   * Update media file with analysis results
   */
  private async updateMediaFileWithAnalysis(
    fileId: number,
    updates: {
      documentAnalysis: DocumentAnalysisResult;
      documentMetadata: DocumentMetadata | null;
      extractedText?: string;
      description: string;
      tags: string[];
      categories: string[];
      processingStatus: ProcessingStatus;
      processedAt: Date;
    }
  ): Promise<void> {
    try {
      await prisma.mediaFile.update({
        where: { id: fileId },
        data: {
          documentMetadata: updates.documentMetadata,
          extractedText: updates.extractedText,
          description: updates.description,
          tags: JSON.stringify(updates.tags),
          categories: JSON.stringify(updates.categories),
          processingStatus: updates.processingStatus,
          processedAt: updates.processedAt
        }
      });
    } catch (updateError) {
      logger.error('Failed to update media file with analysis', {
        operation: 'analysis-update',
        metadata: {
          fileId,
          error: String(updateError)
        }
      });
    }
  }

  /**
   * Search documents by content
   */
  public async searchDocumentsByContent(
    query: string,
    userId: string,
    options: { limit?: number; documentType?: string } = {}
  ): Promise<MediaFile[]> {
    try {
      const limit = options.limit || 10;

      const files = await prisma.mediaFile.findMany({
        where: {
          userId,
          fileType: 'document',
          processingStatus: 'completed',
          OR: [
            { description: { contains: query } },
            { extractedText: { contains: query } },
            { tags: { contains: query } }
          ]
        },
        orderBy: { createdAt: 'desc' },
        take: limit
      });

      return files as MediaFile[];

    } catch (error) {
      logger.error('Failed to search documents by content', {
        operation: 'document-search',
        metadata: {
          userId,
          query,
          error: String(error)
        }
      });
      return [];
    }
  }
}
