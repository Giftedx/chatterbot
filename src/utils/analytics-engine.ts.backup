/**
 * Real-Time Analytics Engine
 * Provides comprehensive real-time analytics, monitoring, and insights
 * for Discord Gemini Bot performance optimization and user behavior analysis.
 */

import { logger } from '../utils/logger.js';
import { PerformanceMonitor } from '../utils/resilience.js';
import { SystemError } from '../utils/errors.js';

export interface AnalyticsEvent {
  id: string;
  timestamp: number;
  type: 'request' | 'response' | 'error' | 'performance' | 'user' | 'system';
  category: string;
  userId?: string;
  guildId?: string;
  data: Record<string, unknown>;
  metadata: {
    source: string;
    version: string;
    sessionId?: string;
    userAgent?: string;
    location?: string;
  };
}

export interface MetricSnapshot {
  timestamp: number;
  category: string;
  metrics: Record<string, number>;
  aggregations: {
    count: number;
    sum: number;
    avg: number;
    min: number;
    max: number;
    percentiles: Record<string, number>;
  };
}

export interface AnalyticsDashboard {
  overview: {
    totalUsers: number;
    activeUsers: number;
    totalRequests: number;
    successRate: number;
    avgResponseTime: number;
    errorRate: number;
  };
  performance: {
    throughput: number;
    latency: {
      p50: number;
      p90: number;
      p95: number;
      p99: number;
    };
    cacheHitRate: number;
    resourceUtilization: {
      memory: number;
      cpu: number;
      connections: number;
    };
  };
  usage: {
    requestsByType: Record<string, number>;
    userDistribution: Record<string, number>;
    timeBasedMetrics: Array<{
      hour: number;
      requests: number;
      users: number;
    }>;
    topGuilds: Array<{
      guildId: string;
      requests: number;
      users: number;
    }>;
  };
  realTime: {
    currentRPS: number;
    activeConnections: number;
    queueSize: number;
    processingTime: number;
    alerts: Array<{
      type: string;
      message: string;
      severity: 'low' | 'medium' | 'high' | 'critical';
      timestamp: number;
    }>;
  };
}

export interface AlertRule {
  id: string;
  name: string;
  type: 'threshold' | 'anomaly' | 'trend';
  metric: string;
  condition: {
    operator: 'gt' | 'lt' | 'eq' | 'gte' | 'lte';
    value: number;
    duration?: number; // Duration in seconds for sustained condition
  };
  severity: 'low' | 'medium' | 'high' | 'critical';
  enabled: boolean;
  cooldown: number; // Cooldown period in seconds
  actions: Array<{
    type: 'log' | 'webhook' | 'email' | 'discord';
    config: Record<string, unknown>;
  }>;
}

/**
 * Advanced real-time analytics engine with intelligent insights and monitoring
 */
export class RealTimeAnalyticsEngine {
  private events: AnalyticsEvent[] = [];
  private metricsBuffer: Map<string, MetricSnapshot[]> = new Map();
  private alertRules: Map<string, AlertRule> = new Map();
  private alertHistory: Map<string, number> = new Map(); // Last alert timestamp per rule
  
  private readonly maxEvents = 100000; // Maximum events to keep in memory
  private readonly maxMetricSnapshots = 1000; // Maximum snapshots per metric
  private readonly snapshotInterval = 60000; // 1 minute snapshots
  private readonly cleanupInterval = 300000; // 5 minute cleanup

  private aggregatedMetrics: Map<string, any> = new Map();
  private realtimeMetrics: AnalyticsDashboard['realTime'] = {
    currentRPS: 0,
    activeConnections: 0,
    queueSize: 0,
    processingTime: 0,
    alerts: []
  };

  private userSessions: Map<string, {
    sessionId: string;
    startTime: number;
    lastActivity: number;
    eventCount: number;
    guildIds: Set<string>;
  }> = new Map();

  constructor() {
    this.initializeDefaultAlerts();
    this.startPeriodicTasks();

    logger.info('RealTimeAnalyticsEngine initialized', {
      operation: 'analytics-init',
      metadata: {
        maxEvents: this.maxEvents,
        snapshotInterval: this.snapshotInterval,
        alertRulesCount: this.alertRules.size
      }
    });
  }

  /**
   * Track an analytics event
   */
  trackEvent(event: Omit<AnalyticsEvent, 'id' | 'timestamp'>): string {
    const analyticsEvent: AnalyticsEvent = {
      ...event,
      id: `evt-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      timestamp: Date.now()
    };

    // Add to events buffer
    this.events.push(analyticsEvent);

    // Maintain buffer size
    if (this.events.length > this.maxEvents) {
      this.events.shift();
    }

    // Update user session tracking
    if (event.userId) {
      this.updateUserSession(event.userId, event.guildId, analyticsEvent.id);
    }

    // Update real-time metrics
    this.updateRealtimeMetrics(analyticsEvent);

    // Process for aggregations
    this.processEventForAggregation(analyticsEvent);

    // Check alert rules
    this.checkAlertRules(analyticsEvent);

    logger.debug('Analytics event tracked', {
      eventId: analyticsEvent.id,
      operation: 'analytics-track',
      metadata: {
        type: event.type,
        category: event.category,
        userId: event.userId,
        dataSize: Object.keys(event.data).length
      }
    });

    return analyticsEvent.id;
  }

  /**
   * Update user session information
   */
  private updateUserSession(userId: string, guildId: string | undefined, eventId: string): void {
    const now = Date.now();
    let session = this.userSessions.get(userId);

    if (!session) {
      session = {
        sessionId: `session-${now}-${Math.random().toString(36).substr(2, 6)}`,
        startTime: now,
        lastActivity: now,
        eventCount: 0,
        guildIds: new Set()
      };
      this.userSessions.set(userId, session);
    }

    session.lastActivity = now;
    session.eventCount++;
    
    if (guildId) {
      session.guildIds.add(guildId);
    }
  }

  /**
   * Update real-time metrics based on events
   */
  private updateRealtimeMetrics(event: AnalyticsEvent): void {
    const now = Date.now();
    const oneMinuteAgo = now - 60000;

    // Calculate current RPS (requests per second)
    const recentEvents = this.events.filter(e => 
      e.timestamp > oneMinuteAgo && e.type === 'request'
    );
    this.realtimeMetrics.currentRPS = recentEvents.length / 60;

    // Update active connections (estimated from recent user activity)
    const activeUsers = new Set();
    this.events.filter(e => e.timestamp > oneMinuteAgo && e.userId)
                .forEach(e => activeUsers.add(e.userId));
    this.realtimeMetrics.activeConnections = activeUsers.size;

    // Update processing time (from recent response events)
    const responseEvents = this.events.filter(e => 
      e.timestamp > oneMinuteAgo && 
      e.type === 'response' && 
      e.data.processingTime
    );
    
    if (responseEvents.length > 0) {
      const avgProcessingTime = responseEvents.reduce((sum, e) => 
        sum + (e.data.processingTime as number), 0
      ) / responseEvents.length;
      this.realtimeMetrics.processingTime = avgProcessingTime;
    }
  }

  /**
   * Process event for metric aggregation
   */
  private processEventForAggregation(event: AnalyticsEvent): void {
    const category = `${event.type}.${event.category}`;
    
    // Extract numeric values for aggregation
    const numericValues: number[] = [];
    Object.values(event.data).forEach(value => {
      if (typeof value === 'number') {
        numericValues.push(value);
      }
    });

    if (numericValues.length === 0) {
      numericValues.push(1); // Count-based metric
    }

    // Update aggregated metrics
    const existing = this.aggregatedMetrics.get(category) || {
      count: 0,
      sum: 0,
      values: []
    };

    existing.count++;
    numericValues.forEach(value => {
      existing.sum += value;
      existing.values.push(value);
    });

    // Keep only recent values for percentile calculation
    if (existing.values.length > 1000) {
      existing.values = existing.values.slice(-1000);
    }

    this.aggregatedMetrics.set(category, existing);
  }

  /**
   * Create metric snapshot
   */
  private createMetricSnapshot(category: string): MetricSnapshot {
    const data = this.aggregatedMetrics.get(category);
    
    if (!data || data.values.length === 0) {
      return {
        timestamp: Date.now(),
        category,
        metrics: {},
        aggregations: {
          count: 0,
          sum: 0,
          avg: 0,
          min: 0,
          max: 0,
          percentiles: {}
        }
      };
    }

    const sortedValues = [...data.values].sort((a, b) => a - b);
    const count = sortedValues.length;
    const sum = data.sum;
    const avg = sum / count;
    const min = sortedValues[0];
    const max = sortedValues[count - 1];

    const percentiles = {
      p50: this.calculatePercentile(sortedValues, 50),
      p90: this.calculatePercentile(sortedValues, 90),
      p95: this.calculatePercentile(sortedValues, 95),
      p99: this.calculatePercentile(sortedValues, 99)
    };

    return {
      timestamp: Date.now(),
      category,
      metrics: {
        count,
        sum,
        avg,
        min,
        max,
        ...percentiles
      },
      aggregations: {
        count,
        sum,
        avg,
        min,
        max,
        percentiles
      }
    };
  }

  /**
   * Calculate percentile value
   */
  private calculatePercentile(sortedValues: number[], percentile: number): number {
    if (sortedValues.length === 0) return 0;
    
    const index = (percentile / 100) * (sortedValues.length - 1);
    const lower = Math.floor(index);
    const upper = Math.ceil(index);
    const weight = index % 1;

    if (lower === upper) {
      return sortedValues[lower];
    }

    return sortedValues[lower] * (1 - weight) + sortedValues[upper] * weight;
  }

  /**
   * Get comprehensive analytics dashboard
   */
  generateDashboard(): AnalyticsDashboard {
    return PerformanceMonitor.monitor('analytics-dashboard', () => {
      const now = Date.now();
      const lastHour = now - 3600000;
      const last24Hours = now - 86400000;

      // Recent events for calculations
      const recentEvents = this.events.filter(e => e.timestamp > lastHour);
      const dailyEvents = this.events.filter(e => e.timestamp > last24Hours);

      // Overview metrics
      const totalUsers = new Set(this.events.map(e => e.userId).filter(Boolean)).size;
      const activeUsers = new Set(recentEvents.map(e => e.userId).filter(Boolean)).size;
      const totalRequests = this.events.filter(e => e.type === 'request').length;
      
      const responseEvents = recentEvents.filter(e => e.type === 'response');
      const errorEvents = recentEvents.filter(e => e.type === 'error');
      const successRate = responseEvents.length > 0 ? 
        (responseEvents.length / (responseEvents.length + errorEvents.length)) : 1;
      
      const avgResponseTime = responseEvents.length > 0 ?
        responseEvents.reduce((sum, e) => sum + (e.data.processingTime as number || 0), 0) / responseEvents.length : 0;
      
      const errorRate = recentEvents.length > 0 ? errorEvents.length / recentEvents.length : 0;

      // Performance metrics
      const latencyValues = responseEvents
        .map(e => e.data.processingTime as number)
        .filter(Boolean)
        .sort((a, b) => a - b);

      const performance = {
        throughput: this.realtimeMetrics.currentRPS,
        latency: {
          p50: this.calculatePercentile(latencyValues, 50),
          p90: this.calculatePercentile(latencyValues, 90),
          p95: this.calculatePercentile(latencyValues, 95),
          p99: this.calculatePercentile(latencyValues, 99)
        },
        cacheHitRate: this.calculateCacheHitRate(recentEvents),
        resourceUtilization: {
          memory: this.estimateMemoryUsage(),
          cpu: this.estimateCpuUsage(),
          connections: this.realtimeMetrics.activeConnections
        }
      };

      // Usage analytics
      const requestsByType = this.aggregateByField(dailyEvents, 'category');
      const userDistribution = this.calculateUserDistribution(dailyEvents);
      const timeBasedMetrics = this.calculateTimeBasedMetrics(dailyEvents);
      const topGuilds = this.calculateTopGuilds(dailyEvents);

      return {
        overview: {
          totalUsers,
          activeUsers,
          totalRequests,
          successRate,
          avgResponseTime,
          errorRate
        },
        performance,
        usage: {
          requestsByType,
          userDistribution,
          timeBasedMetrics,
          topGuilds
        },
        realTime: this.realtimeMetrics
      };
    });
  }

  /**
   * Calculate cache hit rate from events
   */
  private calculateCacheHitRate(events: AnalyticsEvent[]): number {
    const cacheEvents = events.filter(e => e.data.cacheHit !== undefined);
    if (cacheEvents.length === 0) return 0;
    
    const hits = cacheEvents.filter(e => e.data.cacheHit === true).length;
    return hits / cacheEvents.length;
  }

  /**
   * Estimate memory usage (simplified)
   */
  private estimateMemoryUsage(): number {
    const eventMemory = this.events.length * 1000; // ~1KB per event estimate
    const metricMemory = this.aggregatedMetrics.size * 5000; // ~5KB per metric
    const sessionMemory = this.userSessions.size * 500; // ~500B per session
    
    const totalBytes = eventMemory + metricMemory + sessionMemory;
    return Math.min(100, (totalBytes / (100 * 1024 * 1024)) * 100); // % of 100MB
  }

  /**
   * Estimate CPU usage (simplified)
   */
  private estimateCpuUsage(): number {
    const recentActivity = this.events.filter(e => 
      e.timestamp > Date.now() - 60000
    ).length;
    
    // Simple heuristic: more recent activity = higher CPU usage
    return Math.min(100, (recentActivity / 100) * 100);
  }

  /**
   * Aggregate events by field
   */
  private aggregateByField(events: AnalyticsEvent[], field: keyof AnalyticsEvent): Record<string, number> {
    const aggregation: Record<string, number> = {};
    
    events.forEach(event => {
      const value = String(event[field] || 'unknown');
      aggregation[value] = (aggregation[value] || 0) + 1;
    });
    
    return aggregation;
  }

  /**
   * Calculate user distribution by activity level
   */
  private calculateUserDistribution(events: AnalyticsEvent[]): Record<string, number> {
    const userActivity: Record<string, number> = {};
    
    events.forEach(event => {
      if (event.userId) {
        userActivity[event.userId] = (userActivity[event.userId] || 0) + 1;
      }
    });

    const distribution = {
      'Light (1-5 requests)': 0,
      'Medium (6-20 requests)': 0,
      'Heavy (21-50 requests)': 0,
      'Power (50+ requests)': 0
    };

    Object.values(userActivity).forEach(count => {
      if (count <= 5) distribution['Light (1-5 requests)']++;
      else if (count <= 20) distribution['Medium (6-20 requests)']++;
      else if (count <= 50) distribution['Heavy (21-50 requests)']++;
      else distribution['Power (50+ requests)']++;
    });

    return distribution;
  }

  /**
   * Calculate time-based metrics
   */
  private calculateTimeBasedMetrics(events: AnalyticsEvent[]): Array<{
    hour: number;
    requests: number;
    users: number;
  }> {
    const hourlyData: Record<number, { requests: number; users: Set<string> }> = {};

    events.forEach(event => {
      const hour = new Date(event.timestamp).getHours();
      
      if (!hourlyData[hour]) {
        hourlyData[hour] = { requests: 0, users: new Set() };
      }
      
      hourlyData[hour].requests++;
      if (event.userId) {
        hourlyData[hour].users.add(event.userId);
      }
    });

    return Array.from({ length: 24 }, (_, hour) => ({
      hour,
      requests: hourlyData[hour]?.requests || 0,
      users: hourlyData[hour]?.users.size || 0
    }));
  }

  /**
   * Calculate top guilds by activity
   */
  private calculateTopGuilds(events: AnalyticsEvent[]): Array<{
    guildId: string;
    requests: number;
    users: number;
  }> {
    const guildData: Record<string, { requests: number; users: Set<string> }> = {};

    events.forEach(event => {
      if (event.guildId) {
        if (!guildData[event.guildId]) {
          guildData[event.guildId] = { requests: 0, users: new Set() };
        }
        
        guildData[event.guildId].requests++;
        if (event.userId) {
          guildData[event.guildId].users.add(event.userId);
        }
      }
    });

    return Object.entries(guildData)
      .map(([guildId, data]) => ({
        guildId,
        requests: data.requests,
        users: data.users.size
      }))
      .sort((a, b) => b.requests - a.requests)
      .slice(0, 10);
  }

  /**
   * Initialize default alert rules
   */
  private initializeDefaultAlerts(): void {
    const defaultAlerts: AlertRule[] = [
      {
        id: 'high-error-rate',
        name: 'High Error Rate',
        type: 'threshold',
        metric: 'error_rate',
        condition: { operator: 'gt', value: 0.1, duration: 300 },
        severity: 'high',
        enabled: true,
        cooldown: 1800,
        actions: [{ type: 'log', config: {} }]
      },
      {
        id: 'slow-response-time',
        name: 'Slow Response Time',
        type: 'threshold',
        metric: 'avg_response_time',
        condition: { operator: 'gt', value: 5000, duration: 600 },
        severity: 'medium',
        enabled: true,
        cooldown: 900,
        actions: [{ type: 'log', config: {} }]
      },
      {
        id: 'high-queue-size',
        name: 'High Queue Size',
        type: 'threshold',
        metric: 'queue_size',
        condition: { operator: 'gt', value: 100 },
        severity: 'high',
        enabled: true,
        cooldown: 600,
        actions: [{ type: 'log', config: {} }]
      }
    ];

    defaultAlerts.forEach(alert => {
      this.alertRules.set(alert.id, alert);
    });
  }

  /**
   * Check alert rules against events
   */
  private checkAlertRules(event: AnalyticsEvent): void {
    this.alertRules.forEach(rule => {
      if (!rule.enabled) return;

      const now = Date.now();
      const lastAlert = this.alertHistory.get(rule.id) || 0;
      
      if (now - lastAlert < rule.cooldown * 1000) {
        return; // Still in cooldown
      }

      const shouldAlert = this.evaluateAlertRule(rule, event);
      
      if (shouldAlert) {
        this.triggerAlert(rule);
        this.alertHistory.set(rule.id, now);
      }
    });
  }

  /**
   * Evaluate if alert rule should trigger
   */
  private evaluateAlertRule(rule: AlertRule, event: AnalyticsEvent): boolean {
    // Simplified rule evaluation - would be more sophisticated in production
    if (rule.metric === 'error_rate' && event.type === 'error') {
      const recentEvents = this.events.filter(e => 
        e.timestamp > Date.now() - 60000
      );
      const errorEvents = recentEvents.filter(e => e.type === 'error');
      const errorRate = errorEvents.length / Math.max(recentEvents.length, 1);
      
      return this.evaluateCondition(errorRate, rule.condition);
    }
    
    if (rule.metric === 'avg_response_time' && event.type === 'response') {
      const responseTime = event.data.processingTime as number;
      return responseTime && this.evaluateCondition(responseTime, rule.condition);
    }

    return false;
  }

  /**
   * Evaluate alert condition
   */
  private evaluateCondition(value: number, condition: AlertRule['condition']): boolean {
    switch (condition.operator) {
      case 'gt': return value > condition.value;
      case 'gte': return value >= condition.value;
      case 'lt': return value < condition.value;
      case 'lte': return value <= condition.value;
      case 'eq': return value === condition.value;
      default: return false;
    }
  }

  /**
   * Trigger alert
   */
  private triggerAlert(rule: AlertRule): void {
    const alert = {
      type: rule.name,
      message: `Alert: ${rule.name} - ${rule.metric} condition met`,
      severity: rule.severity,
      timestamp: Date.now()
    };

    this.realtimeMetrics.alerts.unshift(alert);
    
    // Keep only recent alerts
    if (this.realtimeMetrics.alerts.length > 50) {
      this.realtimeMetrics.alerts = this.realtimeMetrics.alerts.slice(0, 50);
    }

    logger.warn('Analytics alert triggered', {
      operation: 'analytics-alert',
      metadata: {
        ruleId: rule.id,
        ruleName: rule.name,
        severity: rule.severity,
        metric: rule.metric
      }
    });
  }

  /**
   * Start periodic background tasks
   */
  private startPeriodicTasks(): void {
    // Create metric snapshots
    setInterval(() => {
      this.aggregatedMetrics.forEach((_, category) => {
        const snapshot = this.createMetricSnapshot(category);
        
        let snapshots = this.metricsBuffer.get(category) || [];
        snapshots.push(snapshot);
        
        if (snapshots.length > this.maxMetricSnapshots) {
          snapshots.shift();
        }
        
        this.metricsBuffer.set(category, snapshots);
      });
    }, this.snapshotInterval);

    // Cleanup old data
    setInterval(() => {
      this.cleanupOldData();
    }, this.cleanupInterval);

    // Session cleanup
    setInterval(() => {
      this.cleanupInactiveSessions();
    }, 300000); // 5 minutes
  }

  /**
   * Cleanup old data to prevent memory leaks
   */
  private cleanupOldData(): void {
    const cutoff = Date.now() - 86400000; // 24 hours

    // Cleanup old events
    this.events = this.events.filter(e => e.timestamp > cutoff);

    // Reset aggregated metrics periodically
    this.aggregatedMetrics.clear();

    logger.debug('Analytics data cleanup completed', {
      operation: 'analytics-cleanup',
      metadata: {
        remainingEvents: this.events.length,
        metricsCategories: this.metricsBuffer.size
      }
    });
  }

  /**
   * Cleanup inactive user sessions
   */
  private cleanupInactiveSessions(): void {
    const cutoff = Date.now() - 1800000; // 30 minutes

    for (const [userId, session] of this.userSessions.entries()) {
      if (session.lastActivity < cutoff) {
        this.userSessions.delete(userId);
      }
    }
  }

  /**
   * Get historical metrics for a category
   */
  getHistoricalMetrics(category: string, hours: number = 24): MetricSnapshot[] {
    const snapshots = this.metricsBuffer.get(category) || [];
    const cutoff = Date.now() - (hours * 3600000);
    
    return snapshots.filter(s => s.timestamp > cutoff);
  }

  /**
   * Export analytics data for external analysis
   */
  exportData(options: {
    includeEvents: boolean;
    includeMetrics: boolean;
    timeRange?: { start: number; end: number };
  }): {
    events?: AnalyticsEvent[];
    metrics?: Record<string, MetricSnapshot[]>;
    dashboard: AnalyticsDashboard;
  } {
    const result: any = {
      dashboard: this.generateDashboard()
    };

    if (options.includeEvents) {
      let events = this.events;
      
      if (options.timeRange) {
        events = events.filter(e => 
          e.timestamp >= options.timeRange!.start && 
          e.timestamp <= options.timeRange!.end
        );
      }
      
      result.events = events;
    }

    if (options.includeMetrics) {
      const metrics: Record<string, MetricSnapshot[]> = {};
      
      this.metricsBuffer.forEach((snapshots, category) => {
        if (options.timeRange) {
          metrics[category] = snapshots.filter(s => 
            s.timestamp >= options.timeRange!.start && 
            s.timestamp <= options.timeRange!.end
          );
        } else {
          metrics[category] = snapshots;
        }
      });
      
      result.metrics = metrics;
    }

    return result;
  }
}

export default RealTimeAnalyticsEngine;
